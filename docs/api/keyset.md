---
title: Pagy::Keyset
category:
  - Feature
  - Class
---

# Pagy::Keyset

Implement wicked-fast, keyset pagination for big data.

!!!  

The class API is documented here, however you should not need to use this
class directly because it is required and used internally by the [keyset extra](/docs/extras/keyset.md)

!!!

## Concept

The "Keyset" pagination, also known as "SQL Seek Method" (and often, improperly called "Cursor" pagination) is a tecnique that totally avoids the slowness of querying pages deep into the collection (i.e. when the `offset` is a big number).

This tecnique comes with that huge advantage and a set of limitations that makes it particularly useful for APIs and pretty useless for UIs. 

!!!info

With the regular `offset` pagination, your UI can perfectly handle also big data, by simply limiting the `:max_pages` (variable) 
that allows to serve, effectively avoiding the problem, albeit limiting the browsing to a the initial pages of the collection. 
When you have to serve millions of records, that is not an option, so that is why you use pagy keyset. 

!!!
## Overview

Pagy Keyset pagination does not waste resources and code complexity checking your scope nor your table config at every request.

That means that you have to be sure that your scope is right, and that your tables have the right indices (for performance). You do it once during development, and pagy will be fast at each request. ;)

### Set

- The set is an Activerecord scope or Sequel Dataset that has been uniquely ordered
- The concatenation of the ordered columns must be unique: add the primary key (usually `:id`) as the last order column as a 
  tie-breaker if the concatenation of the ordered columns might not be unique

### Constraints

Like any keyset pagination:
  - You don't know the record count nor the page count
  - The pages have no number
  - You cannot jump to an arbitrary page
  - You can only get the next page
  - You know that you reached the end of the collection when `pagy.next.nil?` 
     
Similarly to the Pagy Offset pagination:
  - You paginate only forward. To go backward... just reverse the order
    in your scope and paginate forward in the reversed order.

And in order to save resources and complexity: you don't know the previous and the last page.

### ORMs

`Pagy::Keyset` implments the classes for `activerecord` or `sequel` sets


## How pagy keyset works

You pass an uniquely ordered set, and `Pagy::Keyset` queries the page of records, keeping track of the last retrieved record by 
encoding the information into the `page` param of the `next` URL. At each request the `:page` is decoded and used to prepare a `when` clause that excludes the records retrived up to that point and includes the number of requested `:items`.

## Methods

==- `Pagy::Keyset.new(set, **vars)`

The constructor takes the `set`, (that can be an activerecord scope or a sequel dataset) and an optional hash of 
[variables](#variables) 

==- `next`

The next `:page`, i.e. the encoded cursor used to exclude the records retrieved up to that point

==- `records`

The array of records in the current page

===

## Variables

=== `:page`

The current page (i.e. the encoded cursor). Default `nil` for the first page

=== `:items`

The number of `:items` per page. Default `DEFAULT[:items]`. You can use the [items extra](/docs/extras/items.md) to get it 
automatically from the request param.

=== `:row_comaprison`

Boolish variable that enables the row comparison query for same-direction keysets (and B-tree indices for performance). Default 
`nil`

==- `:where_query`

A literal query with the keyset columns placeholder for interpolation. Default `nil`. When set, it will override the query 
automatically generated by pagy.

This query is used to exclude the retrieved records using the keyset columns, and it is interpolated with the page 
cursor. Use it for DB-specific extra optimization if you know what you are doing

===
