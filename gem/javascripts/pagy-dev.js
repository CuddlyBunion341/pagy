// pagy.ts
window.Pagy = (() => {
  const rjsObserver = new ResizeObserver((entries) => entries.forEach((e) => e.target.querySelectorAll(".pagy-rjs").forEach((el) => el.pagyRender())));
  const initNav = (el, [tokens, sequels, labelSequels, trimParam]) => {
    const container = el.parentElement ?? el;
    const widths = Object.keys(sequels).map((w) => parseInt(w)).sort((a, b) => b - a);
    let lastWidth = -1;
    const fillIn = (a, page, label) => a.replace(/__pagy_page__/g, page).replace(/__pagy_label__/g, label);
    (el.pagyRender = function() {
      const width = widths.find((w) => w < container.clientWidth) || 0;
      if (width === lastWidth) {
        return;
      }
      let html = tokens.before;
      const series = sequels[width.toString()];
      const labels = labelSequels?.[width.toString()] ?? series.map((l) => l.toString());
      for (const i in series) {
        const item = series[i];
        const label = labels[i];
        let filled;
        if (typeof item === "number") {
          filled = fillIn(tokens.a, item.toString(), label);
        } else if (item === "gap") {
          filled = tokens.gap;
        } else {
          filled = fillIn(tokens.current, item, label);
        }
        html += typeof trimParam === "string" && item == 1 ? trim(filled, trimParam) : filled;
      }
      html += tokens.after;
      el.innerHTML = "";
      el.insertAdjacentHTML("afterbegin", html);
      lastWidth = width;
    })();
    if (el.classList.contains("pagy-rjs")) {
      rjsObserver.observe(container);
    }
  };
  const initCombo = (el, [url_token, trimParam]) => initInput(el, (inputValue) => [inputValue, url_token.replace(/__pagy_page__/, inputValue)], trimParam);
  const initSelector = (el, [from, url_token, trimParam]) => {
    initInput(el, (inputValue) => {
      const page = Math.max(Math.ceil(from / parseInt(inputValue)), 1).toString();
      const url = url_token.replace(/__pagy_page__/, page).replace(/__pagy_items__/, inputValue);
      return [page, url];
    }, trimParam);
  };
  const initInput = (el, getVars, trimParam) => {
    const input = el.querySelector("input");
    const link = el.querySelector("a");
    const initial = input.value;
    const action = function() {
      if (input.value === initial) {
        return;
      }
      const [min, val, max] = [input.min, input.value, input.max].map((n) => parseInt(n) || 0);
      if (val < min || val > max) {
        input.value = initial;
        input.select();
        return;
      }
      let [page, url] = getVars(input.value);
      if (typeof trimParam === "string" && page === "1") {
        url = trim(url, trimParam);
      }
      link.href = url;
      link.click();
    };
    ["change", "focus"].forEach((e) => input.addEventListener(e, input.select));
    input.addEventListener("focusout", action);
    input.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        action();
      }
    });
  };
  const trim = (a, param) => a.replace(new RegExp(`[?&]${param}=1\\b(?!&)|\\b${param}=1&`), "");
  return {
    version: "8.4.1",
    init(arg) {
      const target = arg instanceof Element ? arg : document;
      const elements = target.querySelectorAll("[data-pagy]");
      for (const el of elements) {
        try {
          const uint8array = Uint8Array.from(atob(el.getAttribute("data-pagy")), (c) => c.charCodeAt(0));
          const [keyword, ...args] = JSON.parse(new TextDecoder().decode(uint8array));
          if (keyword === "nav") {
            initNav(el, args);
          } else if (keyword === "combo") {
            initCombo(el, args);
          } else if (keyword === "selector") {
            initSelector(el, args);
          } else {
            console.warn("Skipped Pagy.init() for: %o\nUnknown keyword '%s'", el, keyword);
          }
        } catch (err) {
          console.warn("Skipped Pagy.init() for: %o\n%s", el, err);
        }
      }
    }
  };
})();

//# debugId=05192D5E2035193864756e2164756e21
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsicGFneS50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsKICAgICJ0eXBlIE5hdkFyZ3MgPSByZWFkb25seSBbVG9rZW5zLCBTZXF1ZWxzLCBudWxsIHwgTGFiZWxTZXF1ZWxzLCBzdHJpbmc/XVxudHlwZSBDb21ib0FyZ3MgPSByZWFkb25seSBbc3RyaW5nLCBzdHJpbmc/XVxudHlwZSBTZWxlY3RvckFyZ3MgPSByZWFkb25seSBbbnVtYmVyLCBzdHJpbmcsIHN0cmluZz9dXG5cbmludGVyZmFjZSBUb2tlbnMge1xuICAgIHJlYWRvbmx5IGJlZm9yZTpzdHJpbmdcbiAgICByZWFkb25seSBhOnN0cmluZ1xuICAgIHJlYWRvbmx5IGN1cnJlbnQ6c3RyaW5nXG4gICAgcmVhZG9ubHkgZ2FwOnN0cmluZ1xuICAgIHJlYWRvbmx5IGFmdGVyOnN0cmluZ1xufVxuXG5pbnRlcmZhY2UgU2VxdWVscyB7cmVhZG9ubHkgW3dpZHRoOnN0cmluZ106KHN0cmluZyB8IG51bWJlcilbXX1cblxuaW50ZXJmYWNlIExhYmVsU2VxdWVscyB7cmVhZG9ubHkgW3dpZHRoOnN0cmluZ106c3RyaW5nW119XG5cbmludGVyZmFjZSBOYXZFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7cGFneVJlbmRlcigpOnZvaWR9XG5cbmNvbnN0IFBhZ3kgPSAoKCkgPT4ge1xuICAgIC8vIFRoZSBvYnNlcnZlciBpbnN0YW5jZSBmb3IgcmVzcG9uc2l2ZSBuYXZzXG4gICAgY29uc3QgcmpzT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goZSA9PiBlLnRhcmdldC5xdWVyeVNlbGVjdG9yQWxsPE5hdkVsZW1lbnQ+KFwiLnBhZ3ktcmpzXCIpLmZvckVhY2goXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9PiBlbC5wYWd5UmVuZGVyKCkpKSk7XG5cbiAgICAvLyBJbml0IHRoZSAqX25hdl9qcyBoZWxwZXJzXG4gICAgY29uc3QgaW5pdE5hdiA9IChlbDpOYXZFbGVtZW50LCBbdG9rZW5zLCBzZXF1ZWxzLCBsYWJlbFNlcXVlbHMsIHRyaW1QYXJhbV06TmF2QXJncykgPT4ge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBlbC5wYXJlbnRFbGVtZW50ID8/IGVsO1xuICAgICAgICBjb25zdCB3aWR0aHMgICAgPSBPYmplY3Qua2V5cyhzZXF1ZWxzKS5tYXAodyA9PiBwYXJzZUludCh3KSkuc29ydCgoYSwgYikgPT4gYiAtIGEpO1xuICAgICAgICBsZXQgbGFzdFdpZHRoICAgPSAtMTtcbiAgICAgICAgY29uc3QgZmlsbEluICAgID0gKGE6c3RyaW5nLCBwYWdlOnN0cmluZywgbGFiZWw6c3RyaW5nKTpzdHJpbmcgPT5cbiAgICAgICAgICAgIGEucmVwbGFjZSgvX19wYWd5X3BhZ2VfXy9nLCBwYWdlKS5yZXBsYWNlKC9fX3BhZ3lfbGFiZWxfXy9nLCBsYWJlbCk7XG4gICAgICAgIChlbC5wYWd5UmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSB3aWR0aHMuZmluZCh3ID0+IHcgPCBjb250YWluZXIuY2xpZW50V2lkdGgpIHx8IDA7XG4gICAgICAgICAgICBpZiAod2lkdGggPT09IGxhc3RXaWR0aCkgeyByZXR1cm4gfSAvLyBubyBjaGFuZ2U6IGFib3J0XG4gICAgICAgICAgICBsZXQgaHRtbCAgICAgPSB0b2tlbnMuYmVmb3JlOyAgLy8gYWxyZWFkeSB0cmltbWVkIGluIGh0bWxcbiAgICAgICAgICAgIGNvbnN0IHNlcmllcyA9IHNlcXVlbHNbd2lkdGgudG9TdHJpbmcoKV07XG4gICAgICAgICAgICBjb25zdCBsYWJlbHMgPSBsYWJlbFNlcXVlbHM/Llt3aWR0aC50b1N0cmluZygpXSA/PyBzZXJpZXMubWFwKGwgPT4gbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtICA9IHNlcmllc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgZmlsbGVkO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBmaWxsZWQgPSBmaWxsSW4odG9rZW5zLmEsIGl0ZW0udG9TdHJpbmcoKSwgbGFiZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSA9PT0gXCJnYXBcIikge1xuICAgICAgICAgICAgICAgICAgICBmaWxsZWQgPSB0b2tlbnMuZ2FwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7IC8vIGFjdGl2ZSBwYWdlXG4gICAgICAgICAgICAgICAgICAgIGZpbGxlZCA9IGZpbGxJbih0b2tlbnMuY3VycmVudCwgaXRlbSwgbGFiZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBodG1sICs9ICh0eXBlb2YgdHJpbVBhcmFtID09PSBcInN0cmluZ1wiICYmIGl0ZW0gPT0gMSkgPyB0cmltKGZpbGxlZCwgdHJpbVBhcmFtKSA6IGZpbGxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh0bWwgKz0gdG9rZW5zLmFmdGVyOyAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYWxpZ24tYXNzaWdubWVudHMvYWxpZ24tYXNzaWdubWVudHNcbiAgICAgICAgICAgIGVsLmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICBlbC5pbnNlcnRBZGphY2VudEhUTUwoXCJhZnRlcmJlZ2luXCIsIGh0bWwpO1xuICAgICAgICAgICAgbGFzdFdpZHRoID0gd2lkdGg7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoXCJwYWd5LXJqc1wiKSkgeyByanNPYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcikgfVxuICAgIH07XG5cbiAgICAvLyBJbml0IHRoZSAqX2NvbWJvX25hdl9qcyBoZWxwZXJzXG4gICAgY29uc3QgaW5pdENvbWJvID0gKGVsOkVsZW1lbnQsIFt1cmxfdG9rZW4sIHRyaW1QYXJhbV06Q29tYm9BcmdzKSA9PlxuICAgICAgICBpbml0SW5wdXQoZWwsIGlucHV0VmFsdWUgPT4gW2lucHV0VmFsdWUsIHVybF90b2tlbi5yZXBsYWNlKC9fX3BhZ3lfcGFnZV9fLywgaW5wdXRWYWx1ZSldLCB0cmltUGFyYW0pO1xuXG4gICAgLy8gSW5pdCB0aGUgaXRlbXNfc2VsZWN0b3JfanMgaGVscGVyXG4gICAgY29uc3QgaW5pdFNlbGVjdG9yID0gKGVsOkVsZW1lbnQsIFtmcm9tLCB1cmxfdG9rZW4sIHRyaW1QYXJhbV06U2VsZWN0b3JBcmdzKSA9PiB7XG4gICAgICAgIGluaXRJbnB1dChlbCwgaW5wdXRWYWx1ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWdlID0gTWF0aC5tYXgoTWF0aC5jZWlsKGZyb20gLyBwYXJzZUludChpbnB1dFZhbHVlKSksIDEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCB1cmwgID0gdXJsX3Rva2VuLnJlcGxhY2UoL19fcGFneV9wYWdlX18vLCBwYWdlKS5yZXBsYWNlKC9fX3BhZ3lfaXRlbXNfXy8sIGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIFtwYWdlLCB1cmxdO1xuICAgICAgICB9LCB0cmltUGFyYW0pO1xuICAgIH07XG5cbiAgICAvLyBJbml0IHRoZSBpbnB1dCBlbGVtZW50XG4gICAgY29uc3QgaW5pdElucHV0ID0gKGVsOkVsZW1lbnQsIGdldFZhcnM6KHY6c3RyaW5nKSA9PiBbc3RyaW5nLCBzdHJpbmddLCB0cmltUGFyYW0/OnN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCAgID0gZWwucXVlcnlTZWxlY3RvcihcImlucHV0XCIpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGxpbmsgICAgPSBlbC5xdWVyeVNlbGVjdG9yKFwiYVwiKSBhcyBIVE1MQW5jaG9yRWxlbWVudDtcbiAgICAgICAgY29uc3QgaW5pdGlhbCA9IGlucHV0LnZhbHVlO1xuICAgICAgICBjb25zdCBhY3Rpb24gID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LnZhbHVlID09PSBpbml0aWFsKSB7IHJldHVybiB9ICAvLyBub3QgY2hhbmdlZFxuICAgICAgICAgICAgY29uc3QgW21pbiwgdmFsLCBtYXhdID0gW2lucHV0Lm1pbiwgaW5wdXQudmFsdWUsIGlucHV0Lm1heF0ubWFwKG4gPT4gcGFyc2VJbnQobikgfHwgMCk7XG4gICAgICAgICAgICBpZiAodmFsIDwgbWluIHx8IHZhbCA+IG1heCkgeyAgLy8gcmVzZXQgaW52YWxpZC9vdXQtb2YtcmFuZ2VcbiAgICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9IGluaXRpYWw7XG4gICAgICAgICAgICAgICAgaW5wdXQuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IFtwYWdlLCB1cmxdID0gZ2V0VmFycyhpbnB1dC52YWx1ZSk7ICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItY29uc3RcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHJpbVBhcmFtID09PSBcInN0cmluZ1wiICYmIHBhZ2UgPT09IFwiMVwiKSB7IHVybCA9IHRyaW0odXJsLCB0cmltUGFyYW0pIH1cbiAgICAgICAgICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICAgICAgICAgIGxpbmsuY2xpY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgW1wiY2hhbmdlXCIsIFwiZm9jdXNcIl0uZm9yRWFjaChlID0+IGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoZSwgaW5wdXQuc2VsZWN0KSk7ICAgICAgICAvLyBhdXRvLXNlbGVjdFxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgYWN0aW9uKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGFjdGlvblxuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5cHJlc3NcIiwgZSA9PiB7IGlmIChlLmtleSA9PT0gXCJFbnRlclwiKSB7IGFjdGlvbigpIH0gfSk7IC8vIHRyaWdnZXIgYWN0aW9uXG4gICAgfTtcblxuICAgIC8vIFRyaW0gdGhlICR7cGFnZS1wYXJhbX09MSBwYXJhbXMgaW4gbGlua3NcbiAgICBjb25zdCB0cmltID0gKGE6c3RyaW5nLCBwYXJhbTpzdHJpbmcpID0+XG4gICAgICAgIGEucmVwbGFjZShuZXcgUmVnRXhwKGBbPyZdJHtwYXJhbX09MVxcXFxiKD8hJil8XFxcXGIke3BhcmFtfT0xJmApLCBcIlwiKTtcblxuICAgIC8vIFB1YmxpYyBpbnRlcmZhY2VcbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uOiBcIjguNC4xXCIsXG5cbiAgICAgICAgLy8gU2NhbiBmb3IgZWxlbWVudHMgd2l0aCBhIFwiZGF0YS1wYWd5XCIgYXR0cmlidXRlIGFuZCBjYWxsIHRoZWlyIGluaXQgZnVuY3Rpb25zIHdpdGggdGhlIGRlY29kZWQgYXJnc1xuICAgICAgICBpbml0KGFyZz86RWxlbWVudCB8IG5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgICA9IGFyZyBpbnN0YW5jZW9mIEVsZW1lbnQgPyBhcmcgOiBkb2N1bWVudDtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRzID0gdGFyZ2V0LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS1wYWd5XVwiKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1aW50OGFycmF5ICAgICAgICAgPSBVaW50OEFycmF5LmZyb20oYXRvYihlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBhZ3lcIikgYXMgc3RyaW5nKSwgYyA9PiBjLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBba2V5d29yZCwgLi4uYXJnc10gPSBKU09OLnBhcnNlKChuZXcgVGV4dERlY29kZXIoKSkuZGVjb2RlKHVpbnQ4YXJyYXkpKTsgLy8gYmFzZTY0LXV0ZjggLT4gSlNPTiAtPiBBcnJheVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5d29yZCA9PT0gXCJuYXZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdE5hdihlbCBhcyBOYXZFbGVtZW50LCBhcmdzIGFzIE5hdkFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleXdvcmQgPT09IFwiY29tYm9cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdENvbWJvKGVsLCBhcmdzIGFzIENvbWJvQXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5d29yZCA9PT0gXCJzZWxlY3RvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0U2VsZWN0b3IoZWwsIGFyZ3MgYXMgU2VsZWN0b3JBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNraXBwZWQgUGFneS5pbml0KCkgZm9yOiAlb1xcblVua25vd24ga2V5d29yZCAnJXMnXCIsIGVsLCBrZXl3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikgeyBjb25zb2xlLndhcm4oXCJTa2lwcGVkIFBhZ3kuaW5pdCgpIGZvcjogJW9cXG4lc1wiLCBlbCwgZXJyKSB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgUGFneTtcbiIKICBdLAogICJtYXBwaW5ncyI6ICI7QUFrQkEsSUFB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
